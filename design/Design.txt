Csci 5103, OS161 PA2: Design Document

I approached the design of the codebase for this assignment with an eye toward simple data structures. There are multiple reasons for this. One is that this assignment has a multitude of complexities that make it easy for data structures designed with good intentions to quickly become cumbersome and hard to use as development progressed. I tried to balance time and space efficiency while creating structures that were unlikely to 'get in the way'.

The design for sys_fork is extremely simple, perhaps barring the machinery needed to track the exit statuses of children that gets set up therein. I created a function proc_create_fork() that handles particularities of process creation for fork and calls proc_create() to handle generalities. Proc_create_fork handles address space set-up specific to fork-spawned processes. Enter_forked_process get set as the entrypoint for the newly created thread and handles assuring the copied trapframe is established on the stack of the new thread according to appropriate parameters.

The pid system required a significant amount of design. The approach for getpid() was to provide a simple-as-possible utility function for users. Within the control flow of my waitpid/_exit system, the functions new_pid and remove_pid are used for pid allocation/recycling. A simple linked node structure was used within a pid_list for tracking active pids within the system. Allocation/deallocation preceded as follows: New pids were created by searching the pid_list until a gap in the natural number ordering of the pids in the list was found. A new pid was allocated the first gap found. For example, if nodes were active containing pids 1, 2, 4, 5..., pid 3 would be allocated to a process requesting a new pid. Pids were removed by simply routing around a pid in the pid_list, and this only occurs within proc_destroy(), which is called in sys__exit(), waitpid(), and proc_exorcise(). 

The waitpid/_exit() system uses a relatively simple scheme to communicate about exit_statuses. It avoids the parent having a list of child proc *'s, which is intentional. Having proc references floating around the systems makes it harder to safely track and destroy processes. Instead, every process has an exit_status struct that stores basic data about its exit condition as well as an exit_needed struct that tracks whether its exit status is needed. Every process's parent has access to a single field within the exit_needed struct. Thus every process also has a series of exit_needed 'mailboxes' for its children, which it uses to indicate to its children that it no longer needs their exit status, in case a parent exits before a child. The advantage of this system is it keeps a relatively minimal scheme of data sharing in a relatively subtle/complex set of system dependencies and procedure requirements.

There are four cases handled by waitpid()/_exit() (order matters in these cases):
	1) Parent calls waitpid(), child _exit()s:
		Waitpid() requests the exit status of the child by waiting for the exit semaphore of the child. When the child executes _exit(), it sets it sees that its exit status is still needed, sets its exit code, signals the semaphore its parent is waiting on, and proceeds to thread_exit(). The parent proceeds to collect the child's exit status and destroys the child process.

	2) Child _exit()s, parent calls waitpid()
		Similar to 1). Here, the child executes _exit(), seeing its exit status is needed (exit_status_needed is initialized to 1 and is flipped off by an exiting parent). It sets its exit code and signals its exit semaphore then thread_exit()s. The parent moves through the semaphore without spinning and collects the code, and finally cleans up the child process.

	3) Parent _exit()s, child exit()s 
		The parent sets the exit status needed fields of all children to 0 and cleans up its exit needed mailbox node structure. If its exit status isn't needed by its own parent, it destroys itself before thread exiting. Otherwise it sets its own exit code and avoids destroying its own process. The child does not set its own exit status when it exits because it has been set as unneeded. Instead it proceeds to destroy its process and thread exit.
	4) Child _exit()s, parent exit()s
		This case is more challenging. When the child exits, its exit status is still shown as needed. Therefore it sets its exit code and does not destroy its own process before thread_exiting. However, the parent exits without collecting the exit status and cleaning up the child process. Thus, proc_exorcise() was introduced to clean up processes in the child's condition here. It is called within proc_create() before a new_pid() is called to allocate the new process's pid. This design ensures that no process fails to be created because a zombie process was holding the last available pid, which can be allocated to the new process.

Execv() presented particular challenges because of the requirement entailed in the man pages that the function be able to handle large argv sizes (64K). Additionally, I discovered that function called to load the new program into the address space destroy access to the userspace memory locations pointed to by the argv structure. This made the idea of copying in the arg strings in small segments and copying them out to the new userspace as I went quite cumbersome and hacky. However, I found that the system handled large kmallocations well, and ultimately the best solution seemed to be cleanly pulling in everything needed in the userspace argv, activating the new address space, loading the elf, and copying out from my kernel heap buffers. This works well, and I was able to ascertain the correct program is executed and the arguments passed through execv arrived as expected. I did notice, however, some strange behavior from the atoi() function called in add.c (which I used for testing). When I called add with operands '1' and '2', for example, it claims the answer after converting to atoi was 0. However, it shows '1' and '2' arriving successfully. Furthermore, I noticed that if I simple declare any to number characters within the file, convert them with atoi() and add them, they also show the answer as 0, even though the string numbers 'operands' were non-zero and positive. This seems to be a quirk of the os161 atoi function.	
